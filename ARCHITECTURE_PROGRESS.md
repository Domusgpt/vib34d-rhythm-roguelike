# Architecture Refactor Progress

## Completed Work
- **Canvas lifecycle stabilisation** – Implemented `CanvasResourcePool` to preallocate per-system layer stacks, register pooled contexts with the resource manager, and coordinate resize handling so visualization swaps no longer churn the DOM or drop WebGL state.【F:src/core/CanvasManager.js†L1-L195】【F:src/core/CanvasManager.js†L197-L334】
- **Engine orchestration foundation** – Added an `EngineCoordinator` that initialises engines in order, provisions shared buffers/textures/shaders once, enforces lifecycle contracts, and relays parameter updates and broadcasts across the active system set.【F:src/core/EngineCoordinator.js†L1-L204】【F:src/core/EngineCoordinator.js†L219-L357】
- **GPU resource management** – Established a `ResourceManager` that registers contexts, tracks buffers/textures/programs, monitors memory pressure, and exposes helpers for common assets like gradients and noise fields.【F:src/core/ResourceManager.js†L1-L160】【F:src/core/ResourceManager.js†L222-L420】
- **Predictable state container** – Delivered a Redux-style `StateManager` with domain reducers, validation/persistence middleware, bounded history, and localStorage restore hooks to centralise gameplay, audio, UI, and system state.【F:src/core/StateManager.js†L1-L120】【F:src/core/StateManager.js†L224-L520】
- **Visualizer facade integration** – Refactored `VisualizerEngine` to assemble the pool/coordinator/managers, mirror audio analytics into state, route gameplay events through broadcasts, and keep visualization parameters aligned with the store.【F:src/core/VisualizerEngine.js†L1-L252】【F:src/core/VisualizerEngine.js†L264-L512】
- **Engine contract alignment** – Updated all visualization systems to accept injected canvas/context bundles, respect externally-driven render loops, expose `render`/`handleResize`/`setActive` hooks, and attach to pooled resources instead of DOM-created canvases.【F:src/core/Engine.js†L1-L118】【F:src/quantum/QuantumEngine.js†L1-L168】【F:src/holograms/RealHolographicSystem.js†L1-L140】【F:src/core/PolychoraSystem.js†L1-L236】
- **Resource usage tracking** – Captured shared buffer/texture/shader ownership per engine and mapped pooled resource handles to durable IDs so the coordinator can record attachment/detachment against the ResourceManager audit trail.【F:src/core/ResourceManager.js†L220-L360】【F:src/core/EngineCoordinator.js†L1-L192】
- **Hypercube fallback integration** – Provisioned dedicated pooled canvases and refactored the hypercube visualizer to consume pooled WebGL contexts, enabling seamless mode toggles without recreating contexts.【F:src/core/CanvasManager.js†L10-L86】【F:src/visualizers/HypercubeGameSystem.js†L1-L120】【F:src/core/VisualizerEngine.js†L180-L224】
- **Shared resource injection (quantum)** – Resolved coordinator resource requirements into concrete handles and injected pooled canvases/contexts and the shared `screen_quad` buffer into the quantum engine so its visualizers reuse managed GPU assets instead of recreating them per layer.【F:src/core/EngineCoordinator.js†L88-L124】【F:src/quantum/QuantumEngine.js†L1-L120】【F:src/quantum/QuantumVisualizer.js†L1-L140】【F:src/quantum/QuantumVisualizer.js†L320-L372】

## Remaining Work Before Refactor & Testing Break
- **Shared resource adoption (remaining engines)** – Extend the per-engine shared-resource injection beyond the quantum system so faceted, holographic, and polychora visualizers also consume pooled buffers/shaders/textures provided by the coordinator rather than instantiating their own copies.【F:src/core/EngineCoordinator.js†L88-L124】【F:src/core/EngineCoordinator.js†L150-L214】
- **Test & validation harness** – Automated tests remain absent; once engines adopt the new interfaces, add orchestration smoke tests (initialisation, switching, teardown) and state persistence checks before the planned testing break.【F:src/core/VisualizerEngine.js†L114-L159】【F:src/core/StateManager.js†L401-L476】

## Next Steps
1. Translate each engine’s `resourceRequirements` into concrete calls that pull pooled buffers/programs/textures from the shared maps, eliminating bespoke GPU setup per engine.
2. Introduce minimal integration tests that exercise engine switching, state restoration, and resource cleanup to validate the refactor before pausing for the testing break.
